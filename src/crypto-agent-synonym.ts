import { AgentBuilder } from "@iqai/adk";
import { EnhancedExaTool, EnhancedExaAnswerTool } from "./tools/exa-tool-advanced.js";
import * as fs from "fs/promises";
import * as path from "path";
import * as dotenv from "dotenv";

dotenv.config();

export class SynonymEnhancedCryptoAgent {
  private exaApiKey: string;
  private togetherApiKey: string;
  private genaiApiKey: string;

  constructor(config: {
    genaiApiKey?: string;
    exaApiKey?: string;
    togetherApiKey?: string;
  }) {
    this.exaApiKey = config.exaApiKey || process.env.EXA_API_KEY || '';
    this.togetherApiKey = config.togetherApiKey || process.env.TOGETHER_API_KEY || '';
    this.genaiApiKey = config.genaiApiKey || process.env.GENAI_API_KEY || '';
    
    if (!this.exaApiKey || !this.togetherApiKey) {
      throw new Error('EXA_API_KEY and TOGETHER_API_KEY required');
    }
  }

  private async generateReport(query: string, result: any, metadata: any): Promise<string> {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const reportDir = path.join(process.cwd(), 'reports');
    await fs.mkdir(reportDir, { recursive: true });
    
    const filename = `crypto-analysis-${timestamp}.md`;
    const filepath = path.join(reportDir, filename);
    
    const report = `# Cryptocurrency Analysis Report

## Query
**${query}**

## Analysis Summary
Generated: ${new Date().toLocaleString()}
Model: ${metadata.model}
Enhanced Search: ${metadata.enhancedSearch ? '‚úÖ' : '‚ùå'}
Synonyms: ${metadata.synonymsEnabled ? '‚úÖ' : '‚ùå'}
Scraping: ${metadata.scrapingEnabled ? '‚úÖ' : '‚ùå'}

## Analysis Results
${result.analysis || result.answer || 'No analysis available'}

## Metadata
\`\`\`json
${JSON.stringify(metadata, null, 2)}
\`\`\`

---
*Report generated by SynonymEnhancedCryptoAgent*
`;

    await fs.writeFile(filepath, report, 'utf-8');
    return filepath;
  }

  async synonymEnhancedAnalyze(query: string, options: {
    enableSynonyms?: boolean;
    enableScraping?: boolean;
    maxSources?: number;
    dateFilter?: string;
    includeDomains?: string[];
    generateReport?: boolean;
  } = {}) {
    const config = {
      enableSynonyms: true,
      enableScraping: true,
      maxSources: 8,
      generateReport: false,
      ...options
    };

    console.log(`üöÄ Synonym-Enhanced Analysis: "${query}"`);

    const tools = [
      new EnhancedExaTool(this.exaApiKey, this.togetherApiKey),
      new EnhancedExaAnswerTool(this.exaApiKey, this.togetherApiKey)
    ];

    const agent = await AgentBuilder
      .create("synonym_enhanced_crypto_agent")
      .withModel("gemini-2.0-flash-exp")
      .withDescription("Cryptocurrency analysis with AI-enhanced web search")
      .withInstruction(`You are a cryptocurrency expert with advanced AI tools. Use enhanced_exa_search for comprehensive analysis and enhanced_exa_answer for specific questions.

Your tools feature:
- AI-powered query expansion with synonyms for better source diversity
- Universal content scraping and cleaning
- Multi-query deduplication and ranking
- Smart relevance filtering

For analysis requests, provide insights covering:
1. Current market dynamics
2. Key drivers and catalysts  
3. Multiple perspective synthesis
4. Future implications
5. Actionable intelligence

Always use the AI-enhanced tools to ensure comprehensive coverage.`)
      .withTools(...tools)
      .build();

    const analysisPrompt = `Please analyze: ${query}

Use enhanced_exa_search with these settings:
- enableSynonyms: ${config.enableSynonyms}
- enableScraping: ${config.enableScraping}
- maxScrape: ${config.maxSources}
${config.dateFilter ? `- dateFilter: ${config.dateFilter}` : ''}
${config.includeDomains ? `- includeDomains: ${JSON.stringify(config.includeDomains)}` : ''}

Provide comprehensive analysis based on the enhanced multi-source results.`;

    try {
      const result = await agent.runner.ask(analysisPrompt);
      
      const metadata = {
        model: "gemini-2.0-flash-exp",
        enhancedSearch: true,
        synonymsEnabled: config.enableSynonyms,
        scrapingEnabled: config.enableScraping,
        maxSources: config.maxSources,
        timestamp: new Date().toISOString()
      };

      let reportPath;
      if (config.generateReport) {
        reportPath = await this.generateReport(query, result, metadata);
        console.log(`üìÑ Report generated: ${reportPath}`);
      }

      return {
        success: true,
        query,
        analysis: result,
        metadata,
        reportPath
      };

    } catch (error) {
      return {
        success: false,
        query,
        error: error instanceof Error ? error.message : String(error),
        metadata: {
          model: "gemini-2.0-flash-exp",
          enhancedSearch: true,
          timestamp: new Date().toISOString()
        }
      };
    }
  }

  async quickAnswer(question: string, options: {
    enableSynonyms?: boolean;
    includeDomains?: string[];
    generateReport?: boolean;
  } = {}) {
    const tools = [
      new EnhancedExaAnswerTool(this.exaApiKey, this.togetherApiKey)
    ];

    const agent = await AgentBuilder
      .create("quick_answer_agent")
      .withModel("gemini-2.0-flash-exp")
      .withDescription("Quick cryptocurrency answers with AI query expansion")
      .withInstruction(`You are a crypto expert. Use enhanced_exa_answer to get the most accurate information with AI query expansion.`)
      .withTools(...tools)
      .build();

    const answerPrompt = `${question}

Use enhanced_exa_answer with settings:
- enableSynonyms: ${options?.enableSynonyms !== false}
${options?.includeDomains ? `- includeDomains: ${JSON.stringify(options.includeDomains)}` : ''}`;

    try {
      const result = await agent.runner.ask(answerPrompt);
      
      const metadata = {
        model: "gemini-2.0-flash-exp",
        synonymsEnabled: options?.enableSynonyms !== false,
        timestamp: new Date().toISOString()
      };

      let reportPath;
      if (options?.generateReport) {
        reportPath = await this.generateReport(question, { answer: result }, metadata);
        console.log(`üìÑ Report generated: ${reportPath}`);
      }

      return {
        success: true,
        question,
        answer: result,
        metadata,
        reportPath
      };

    } catch (error) {
      return {
        success: false,
        question,
        error: error instanceof Error ? error.message : String(error),
        metadata: {
          model: "gemini-2.0-flash-exp",
          timestamp: new Date().toISOString()
        }
      };
    }
  }
}